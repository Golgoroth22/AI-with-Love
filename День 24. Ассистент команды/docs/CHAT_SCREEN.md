# ChatScreen - Main Chat Interface Documentation

## Overview

The ChatScreen is the primary interface of the AI with Love application, implementing an agentic chat system that automatically detects user intent and calls appropriate MCP tools to fulfill requests. It features advanced capabilities including semantic search with dynamic threshold filtering, automatic dialog compression, and comprehensive token tracking.

**File Locations:**
- **UI**: `app/src/main/java/com/example/aiwithlove/ui/ChatScreen.kt`
- **ViewModel**: `app/src/main/java/com/example/aiwithlove/viewmodel/ChatViewModel.kt` (870+ lines)

---

## Table of Contents

1. [Core Chat Features](#1-core-chat-features)
2. [Agentic Tool System](#2-agentic-tool-system)
3. [Semantic Search with Threshold Filtering](#3-semantic-search-with-threshold-filtering)
4. [Token Counting & Metrics](#4-token-counting--metrics)
5. [Dialog Compression](#5-dialog-compression)
6. [Advanced Features](#6-advanced-features)
7. [Configuration & Management](#7-configuration--management)

---

## 1. Core Chat Features

### 1.1 Message Display & Management

**Implementation**: ChatScreen.kt lines 172-400

#### Message Bubbles
- **User messages**: Right-aligned, primary color background
- **AI responses**: Left-aligned, surface variant color background
- **System messages**: Special formatting for compression notices and summaries
- **Rounded corners**: Material Design 3 style with 12.dp corner radius

#### Auto-Scrolling
```kotlin
LazyColumn(
    state = listState,
    modifier = Modifier.fillMaxSize()
) {
    // Messages displayed here
}

// Auto-scroll to latest message
LaunchedEffect(messages.size) {
    if (messages.isNotEmpty()) {
        listState.animateScrollToItem(messages.size - 1)
    }
}
```

#### Message Filtering
- Excludes summary messages from main display (line 172)
- Filters out "thinking" messages during processing
- Shows compression notices when dialog summarization occurs

#### Timestamp Tracking
- Each message records creation time via `System.currentTimeMillis()`
- Timestamps stored in Room database
- Used for message ordering and history management

### 1.2 Message Types

The system supports multiple message types:
- **Regular User Messages**: Standard text input from user
- **AI Responses**: Generated by Perplexity API (openai/gpt-5-mini model)
- **System Messages**: Compression notices, welcome messages
- **Summary Messages**: Compressed conversation history (marked with `isCompressed = true`)
- **Tool Info Messages**: Display which tools were called and their results

---

## 2. Agentic Tool System

### 2.1 Tool Detection Logic

**Implementation**: ChatViewModel.kt lines 651-655

The system automatically detects user intent through keyword matching:

#### Semantic Search Detection
```kotlin
private fun userMentionsSemanticSearch(message: String): Boolean {
    val lowerMessage = message.lowercase()
    val keywords = listOf(
        "–Ω–∞–π–¥–∏ –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ö",
        "–ø–æ–∏—Å–∫ –≤ –±–∞–∑–µ",
        "—á—Ç–æ –≥–æ–≤–æ—Ä–∏—Ç—Å—è –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ö",
        "–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ",
        "—Ä–∞—Å—Å–∫–∞–∂–∏ –æ",
        "—á—Ç–æ —Ç–∞–∫–æ–µ",
        "–∫–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç",
        "–æ–±—ä—è—Å–Ω–∏",
        "–¥–æ–∫—É–º–µ–Ω—Ç"
    )
    return keywords.any { lowerMessage.contains(it) }
}
```

### 2.2 Dynamic Tool List Building

**Implementation**: ChatViewModel.kt lines 681-691

Based on detected keywords, the system dynamically builds the tool list sent to the API:

```kotlin
val tools = buildList {
    if (useSemanticSearch) {
        add(buildSemanticSearchTool())    // semantic_search
    }
}.takeIf { it.isNotEmpty() }
```

**Tool Count by Query Type:**
- Semantic search keywords: 1 tool (semantic_search)
- No relevant keywords: 0 tools (null) - normal conversation

### 2.3 Iterative Tool Loop

**Implementation**: ChatViewModel.kt lines 772-850

The agentic loop supports up to **5 iterations** of tool calling:

```kotlin
// Maximum tool call iterations
private val maxToolIterations = 5
var currentIteration = 0

while (currentIteration < maxToolIterations) {
    // 1. Parse API response
    val response = parseAgenticResponse(jsonResponse)

    // 2. Check if tool call is needed
    if (response.toolCalls.isNotEmpty()) {
        // 3. Execute tool via MCP server
        val toolResult = executeAgenticToolCall(toolCall)

        // 4. Submit result back to API
        submitToolResult(toolUseId, toolResult)

        currentIteration++
    } else {
        // 5. Final text response received
        break
    }
}
```

**Flow Diagram:**
```
User Message ‚Üí Keyword Detection ‚Üí Tool Selection
     ‚Üì
Send to Perplexity API with tool definitions
     ‚Üì
API decides: "Call semantic_search tool"
     ‚Üì
Execute tool via McpClient ‚Üí MCP Server
     ‚Üì
Submit tool result back to API
     ‚Üì
API generates final response with results
     ‚Üì
Display to user
```

### 2.4 Tool Execution

**Implementation**: ChatViewModel.kt lines 291-500

Each tool has a dedicated execution handler:

#### Semantic Search Tool
```kotlin
"semantic_search" -> {
    val query = args["query"]?.jsonPrimitive?.content ?: ""
    val limit = args["limit"]?.jsonPrimitive?.int ?: 3

    // Use current threshold from UI state
    val threshold = _searchThreshold.value

    val result = mcpClient.callTool(
        toolName = "semantic_search",
        arguments = buildJsonObject {
            put("query", query)
            put("limit", limit)
            put("threshold", threshold)
            put("compare_mode", _compareMode.value)
        }
    )
}
```

---

## 3. Semantic Search with Threshold Filtering

**‚≠ê Day 18 Main Feature**

### 3.1 Threshold Control Panel

**Implementation**: ChatScreen.kt lines 943-1040

#### UI Components
```kotlin
// Expandable control panel
var expanded by remember { mutableStateOf(false) }

Card(
    modifier = Modifier
        .fillMaxWidth()
        .padding(16.dp)
        .clickable { expanded = !expanded }
) {
    Row {
        Icon(Icons.Default.Tune, "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–∏—Å–∫–∞")
        Text("–ü–æ—Ä–æ–≥ —Å—Ö–æ–∂–µ—Å—Ç–∏: ${(threshold * 100).toInt()}%")
    }

    if (expanded) {
        // Threshold slider
        Slider(
            value = threshold,
            onValueChange = { viewModel.updateSearchThreshold(it) },
            valueRange = 0.3f..0.95f,
            steps = 12
        )

        // Comparison mode toggle
        Row {
            Switch(
                checked = compareMode,
                onCheckedChange = { viewModel.toggleCompareMode() }
            )
            Text("–†–µ–∂–∏–º —Å—Ä–∞–≤–Ω–µ–Ω–∏—è")
        }
    }
}
```

### 3.2 Threshold Range

**Configuration**: ChatViewModel.kt lines 30-34
```kotlin
// Threshold configuration
const val MIN_THRESHOLD = 0.3f  // 30% similarity
const val MAX_THRESHOLD = 0.95f // 95% similarity
const val DEFAULT_THRESHOLD = 0.7f // 70% similarity
```

### 3.3 Comparison Mode

**Implementation**: ChatViewModel.kt lines 603-608

When enabled, displays both filtered and unfiltered results side-by-side:

```kotlin
if (compareMode) {
    // Show both filtered and unfiltered results
    Column {
        Text("–ë–µ–∑ —Ñ–∏–ª—å—Ç—Ä–∞ (${unfilteredCount} –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤):")
        unfilteredResults.forEach { doc ->
            DocumentCard(doc, highlighted = false)
        }

        Text("–° –ø–æ—Ä–æ–≥–æ–º ${threshold} (${filteredCount} –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤):")
        filteredResults.forEach { doc ->
            DocumentCard(doc, highlighted = true)
        }
    }
}
```

### 3.4 Similarity Score Visualization

**Implementation**: ChatScreen.kt lines 421-513

Color-coded similarity bars:
- **Green**: Similarity ‚â• 80% (high relevance)
- **Orange**: Similarity ‚â• 60% (medium relevance)
- **Red**: Similarity < 60% (low relevance)

```kotlin
Box(
    modifier = Modifier
        .fillMaxWidth()
        .height(4.dp)
        .background(
            when {
                similarity >= 0.8f -> Color.Green
                similarity >= 0.6f -> Color(0xFFFFA500) // Orange
                else -> Color.Red
            }
        )
)
```

---

## 4. Token Counting & Metrics

### 4.1 Token Display

**Implementation**: ChatScreen.kt lines 421-513

Each message displays token usage:
```kotlin
// Prompt tokens (üì§ icon)
Row {
    Text("üì§ ${message.promptTokens}")
}

// Completion tokens (üì• icon)
Row {
    Text("üì• ${message.completionTokens}")
}
```

### 4.2 Token Tracking

**Implementation**: ChatViewModel.kt lines 815-816

Extracted from Perplexity API response:
```kotlin
val usage = response["usage"]?.jsonObject
val promptTokens = usage?.get("prompt_tokens")?.jsonPrimitive?.int ?: 0
val completionTokens = usage?.get("completion_tokens")?.jsonPrimitive?.int ?: 0

// Attach to message
message.copy(
    promptTokens = promptTokens,
    completionTokens = completionTokens
)
```

### 4.3 Token Optimization

The system optimizes token usage through:
1. **Dialog Compression**: Summarizes history after 5 messages
2. **Tool Selection**: Only includes relevant tools in API request
3. **Context Management**: Limits context to last 10 messages

---

## 5. Dialog Compression

### 5.1 Compression Trigger

**Implementation**: ChatViewModel.kt lines 969-1109

Automatic compression after every **5 user messages**:

```kotlin
companion object {
    private const val COMPRESSION_THRESHOLD = 5
}

private var messageCountSinceLastCompression = 0

fun sendMessage(text: String) {
    // ... send message logic ...

    messageCountSinceLastCompression++

    if (messageCountSinceLastCompression >= COMPRESSION_THRESHOLD) {
        compressDialog()
        messageCountSinceLastCompression = 0
    }
}
```

### 5.2 Compression Process

```kotlin
private suspend fun compressDialog() {
    // 1. Show compression notice
    addMessage(Message(
        content = "üóúÔ∏è –°–∂–∏–º–∞—é –∏—Å—Ç–æ—Ä–∏—é –¥–∏–∞–ª–æ–≥–∞...",
        role = Role.SYSTEM
    ))

    // 2. Get all messages to compress
    val messagesToCompress = chatRepository.getAllMessages()
        .filter { !it.isCompressed }

    // 3. Send to API for summarization
    val summary = perplexityApi.summarizeConversation(
        messages = messagesToCompress.map {
            mapOf("role" to it.role.name, "content" to it.content)
        }
    )

    // 4. Save summary to database
    chatRepository.saveSummary(summary)

    // 5. Mark old messages as compressed
    messagesToCompress.forEach { message ->
        chatRepository.updateMessage(
            message.copy(isCompressed = true)
        )
    }

    // 6. Clear UI and show summary
    _messages.value = listOf(
        Message(
            content = "üìù –ò—Å—Ç–æ—Ä–∏—è —Å–∂–∞—Ç–∞. –ö—Ä–∞—Ç–∫–æ–µ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ:\n\n$summary",
            role = Role.SYSTEM,
            isSummary = true
        )
    )
}
```

### 5.3 Summary Storage

Summaries are stored in the database and included in future context:
```kotlin
// Load context with summaries
val context = buildList {
    // Include latest summary if exists
    val lastSummary = chatRepository.getLatestSummary()
    lastSummary?.let { add(it) }

    // Include last 10 regular messages
    val recentMessages = chatRepository.getRecentMessages(limit = 10)
    addAll(recentMessages)
}
```

---

## 6. Advanced Features

### 6.1 Typewriter Effect

**Implementation**: ChatViewModel.kt lines 892-967

Character-by-character animation for AI responses:

```kotlin
private suspend fun displayMessageWithTypewriter(message: Message, index: Int) {
    val fullText = message.content
    val delay = 30L // 30ms delay
    val charsPerStep = 3 // 3 characters at a time

    var currentText = ""

    for (i in fullText.indices step charsPerStep) {
        val endIndex = minOf(i + charsPerStep, fullText.length)
        currentText = fullText.substring(0, endIndex)

        // Update message in list
        val updatedMessages = _messages.value.toMutableList()
        updatedMessages[index] = message.copy(content = currentText)
        _messages.value = updatedMessages

        delay(delay)
    }

    // Attach token counts after animation completes
    val finalMessage = message.copy(
        content = fullText,
        promptTokens = extractedPromptTokens,
        completionTokens = extractedCompletionTokens
    )
    updateMessage(index, finalMessage)
}
```

**Timing**: 3 characters every 30ms = ~100 characters per second

### 6.2 Conversation Context Management

**Implementation**: ChatViewModel.kt lines 877-890

Builds context with last 10 messages for API requests:

```kotlin
private fun buildConversationContext(): List<Map<String, String>> {
    return _messages.value
        .filter { it.role != Role.THINKING && !it.isSummary }
        .takeLast(10) // Last 10 messages
        .map { message ->
            mapOf(
                "role" to when (message.role) {
                    Role.USER -> "user"
                    Role.ASSISTANT -> "assistant"
                    Role.SYSTEM -> "system"
                    else -> "user"
                },
                "content" to message.content
            )
        }
}
```

### 6.4 Database Integration

**Implementation**: ChatViewModel.kt lines 653-707, 954-960

#### Message Persistence
```kotlin
// Save user message
suspend fun saveUserMessage(content: String): Long {
    return chatRepository.insertMessage(
        Message(
            content = content,
            role = Role.USER,
            timestamp = System.currentTimeMillis()
        )
    )
}

// Save AI response
suspend fun saveAssistantMessage(content: String, promptTokens: Int, completionTokens: Int) {
    chatRepository.insertMessage(
        Message(
            content = content,
            role = Role.ASSISTANT,
            timestamp = System.currentTimeMillis(),
            promptTokens = promptTokens,
            completionTokens = completionTokens
        )
    )
}
```

#### History Loading
```kotlin
init {
    viewModelScope.launch {
        // Load chat history on startup
        val history = chatRepository.getAllMessages()
            .filter { !it.isCompressed } // Exclude compressed messages

        _messages.value = history
    }
}
```

#### Clear Functionality
```kotlin
fun clearChat() {
    viewModelScope.launch {
        // Clear database
        chatRepository.deleteAllMessages()
        chatRepository.deleteAllSummaries()

        // Clear UI
        _messages.value = emptyList()
        messageCountSinceLastCompression = 0

        logD("üóëÔ∏è Chat cleared")
    }
}
```

---

## 7. Configuration & Management

### 7.1 MCP Server Management

**Implementation**: ChatScreen.kt lines 51-80, ChatViewModel.kt lines 86-87

#### Server Toggle Dialog
```kotlin
var showServerDialog by remember { mutableStateOf(false) }

// Top app bar button
IconButton(onClick = { showServerDialog = true }) {
    Badge(
        content = { Text("${enabledServersCount}") }
    ) {
        Icon(Icons.Default.Settings, "MCP Servers")
    }
}

// Server selection dialog
if (showServerDialog) {
    AlertDialog(
        title = { Text("MCP Servers") },
        text = {
            Column {
                McpServerConfig.AVAILABLE_SERVERS.forEach { server ->
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable {
                                viewModel.toggleServer(server.id)
                            }
                    ) {
                        Checkbox(
                            checked = server.id in viewModel.enabledServers.value,
                            onCheckedChange = {
                                viewModel.toggleServer(server.id)
                            }
                        )
                        Text(server.name)
                    }
                }
            }
        },
        confirmButton = {
            TextButton(onClick = { showServerDialog = false }) {
                Text("Close")
            }
        }
    )
}
```

### 7.2 Keyboard & Input Handling

**Implementation**: ChatScreen.kt lines 79-83, 199-246

#### Text Input Field
```kotlin
OutlinedTextField(
    value = messageText,
    onValueChange = { messageText = it },
    modifier = Modifier
        .fillMaxWidth()
        .padding(8.dp),
    placeholder = { Text("–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ...") },
    maxLines = 4,
    enabled = !isLoading,
    shape = RoundedCornerShape(24.dp),
    keyboardOptions = KeyboardOptions(
        imeAction = ImeAction.Send
    ),
    keyboardActions = KeyboardActions(
        onSend = {
            if (messageText.isNotBlank() && !isLoading) {
                viewModel.sendMessage(messageText)
                messageText = ""
                keyboardController?.hide()
            }
        }
    )
)
```

#### Send Button
```kotlin
FloatingActionButton(
    onClick = {
        if (messageText.isNotBlank() && !isLoading) {
            viewModel.sendMessage(messageText)
            messageText = ""
        }
    },
    enabled = messageText.isNotBlank() && !isLoading
) {
    if (isLoading) {
        CircularProgressIndicator(
            modifier = Modifier.size(24.dp),
            color = MaterialTheme.colorScheme.onPrimary
        )
    } else {
        Icon(Icons.AutoMirrored.Filled.Send, "Send")
    }
}
```

### 7.3 UI/UX Features

**Material Design 3 Implementation**: ChatScreen.kt throughout

#### Adaptive Colors
```kotlin
// User message bubble
Card(
    colors = CardDefaults.cardColors(
        containerColor = MaterialTheme.colorScheme.primary
    )
) {
    Text(
        text = message.content,
        color = MaterialTheme.colorScheme.onPrimary
    )
}

// AI message bubble
Card(
    colors = CardDefaults.cardColors(
        containerColor = MaterialTheme.colorScheme.surfaceVariant
    )
) {
    Text(
        text = message.content,
        color = MaterialTheme.colorScheme.onSurfaceVariant
    )
}
```

#### Keyboard Padding
```kotlin
Scaffold(
    modifier = Modifier
        .fillMaxSize()
        .imePadding() // Ensures content visible above keyboard
) {
    // Content
}
```

#### Accessibility
```kotlin
Icon(
    imageVector = Icons.Default.Send,
    contentDescription = "–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ" // Russian: Send message
)

Button(
    onClick = { /* ... */ },
    modifier = Modifier.semantics {
        contentDescription = "–û—á–∏—Å—Ç–∏—Ç—å —á–∞—Ç" // Russian: Clear chat
    }
) {
    Text("–û—á–∏—Å—Ç–∏—Ç—å")
}
```

---

## Configuration Constants

**File**: ChatViewModel.kt companion object (lines 1111-1125)

```kotlin
companion object {
    // Compression
    private const val COMPRESSION_THRESHOLD = 5 // Messages before compression

    // API
    private const val AGENTIC_MODEL = "openai/gpt-5-mini"
    private const val MAX_TOOL_ITERATIONS = 5

    // Context
    private const val MAX_CONTEXT_MESSAGES = 10

    // Typewriter
    private const val TYPEWRITER_DELAY_MS = 30L
    private const val TYPEWRITER_CHARS_PER_STEP = 3

    // Semantic Search
    private const val DEFAULT_THRESHOLD = 0.7f
    private const val MIN_THRESHOLD = 0.3f
    private const val MAX_THRESHOLD = 0.95f
    private const val DEFAULT_SEARCH_LIMIT = 3

    // Welcome Message
    private const val CONGRATS_MESSAGE = """
        üéâ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ AI with Love!

        –î–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:
        üåê –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ö
        üêô GitHub –æ–ø–µ—Ä–∞—Ü–∏–∏
        üåø –õ–æ–∫–∞–ª—å–Ω—ã–π Git

        –ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –∏ —è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏—Å–ø–æ–ª—å–∑—É—é –Ω—É–∂–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã!
    """.trimIndent()
}
```

---

## Troubleshooting

### Tool Not Triggered

**Symptom**: Tool doesn't execute even with correct keywords

**Solutions**:
1. Check if MCP server is enabled in settings dialog
2. Verify keywords in `userMentionsSemanticSearch()`, `userMentionsGitHub()`, or `userMentionsLocalGit()`
3. Check logs for tool detection messages
4. Ensure MCP server is running on http://10.0.2.2:8080

### Compression Not Working

**Symptom**: Dialog doesn't compress after 5 messages

**Solutions**:
1. Check `messageCountSinceLastCompression` counter
2. Verify `COMPRESSION_THRESHOLD` value (default: 5)
3. Check logs for "üóúÔ∏è –°–∂–∏–º–∞—é –∏—Å—Ç–æ—Ä–∏—é –¥–∏–∞–ª–æ–≥–∞..." message
4. Ensure Perplexity API is responding

### Token Counts Not Showing

**Symptom**: Token metrics not displayed under messages

**Solutions**:
1. Verify Perplexity API response includes `usage` field
2. Check `extractTokenUsage()` method parsing
3. Ensure message updates after typewriter effect completes

### Threshold Slider Not Affecting Results

**Symptom**: Changing threshold doesn't filter results

**Solutions**:
1. Verify `updateSearchThreshold()` is called
2. Check `_searchThreshold` StateFlow is updated
3. Ensure threshold is passed to `semantic_search` tool call
4. Check MCP server applies threshold correctly

---

## Related Documentation

- [SEMANTIC_SEARCH.md](../server/SEMANTIC_SEARCH.md) - Semantic search implementation details
- [OLLAMA_SCREEN.md](OLLAMA_SCREEN.md) - Document indexing screen
- [SERVER_README.md](../server/SERVER_README.md) - MCP server overview

---

## Version

**Day 18**: –†–µ—Ä–∞–Ω–∫–∏–Ω–≥ –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è (Reranking and Filtering)

**Last Updated**: 2026-02-04
